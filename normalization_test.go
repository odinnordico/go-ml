package learn

import (
	"reflect"
	"testing"

	"gonum.org/v1/gonum/mat"
)

func Test_featureNormalizationScaling(t *testing.T) {
	const rows = 16
	const cols = 4
	Xnorm := mat.NewDense(rows, cols, []float64{
		1, 1, 1, 1,
		0.7369863013698631, 0.7042403296557225, 0.7186925145040329, 0.7228576456097132,
		0.06027397260273973, 0.032300943772431194, 0.05372859770765532, 0.07620568767850136,
		0.9397260273972603, 0.9037617971553902, 0.9589641998018962, 0.9212360752040499,
		0.6219178082191782, 0.6098630865346272, 0.6272817319937738, 0.6220982958621529,
		0.5986301369863015, 0.5813771101954008, 0.603976227536437, 0.5948916471527769,
		0.4671232876712329, 0.45566928087199254, 0.47601528229800477, 0.4638665926718012,
		0.34109589041095895, 0.3437458460720457, 0.34470072166407245, 0.34705396662109667,
		0.18767123287671234, 0.13664761398378308, 0.15055893589925004, 0.18151301452374832,
		0, 0, 0, 0,
		0.273972602739726, 0.26864282865877975, 0.2796094523843215, 0.2704422095588733,
		0.2054794520547945, 0.2078957862554832, 0.2029149568416584, 0.18909297635322625,
		0.4616438356164384, 0.4486242190615446, 0.4703551719258525, 0.44762381732291995,
		0.4356164383561644, 0.43705968363684705, 0.45761992358850995, 0.41919896046237765,
		0.34246575342465757, 0.3337764189817892, 0.35531342861185794, 0.3425872034001543,
		0.6479452054794521, 0.6111923434799947, 0.6697325597849159, 0.6357828340935854,
	})
	X := mat.NewDense(rows, cols, getDefaultXsamplesNoBiasSlice())
	max := []float64{4.52, 4.725, 4.333, 4.5909}
	min := []float64{-2.78, -2.798, -2.734, -2.797}
	type args struct {
		X *mat.Dense
	}
	tests := []struct {
		name  string
		args  args
		want  *mat.Dense
		want1 []float64
		want2 []float64
	}{
		{
			"Feature scalling with rescaling",
			args{X},
			Xnorm,
			max,
			min,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, got1, got2 := featureNormalizationScaling(tt.args.X)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("featureNormalizationScaling() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("featureNormalizationScaling() got1 = %v, want %v", got1, tt.want1)
			}
			if !reflect.DeepEqual(got2, tt.want2) {
				t.Errorf("featureNormalizationScaling() got2 = %v, want %v", got2, tt.want2)
			}
		})
	}
}

func Test_featureNormalizationMeanWithMaxMin(t *testing.T) {
	const rows = 16
	const cols = 4
	Xnorm := mat.NewDense(rows, cols, []float64{
		1, 1, 1, 1,
		0.7369863013698631, 0.7042403296557225, 0.7186925145040329, 0.7228576456097132,
		0.06027397260273973, 0.032300943772431194, 0.05372859770765532, 0.07620568767850136,
		0.9397260273972603, 0.9037617971553902, 0.9589641998018962, 0.9212360752040499,
		0.6219178082191782, 0.6098630865346272, 0.6272817319937738, 0.6220982958621529,
		0.5986301369863015, 0.5813771101954008, 0.603976227536437, 0.5948916471527769,
		0.4671232876712329, 0.45566928087199254, 0.47601528229800477, 0.4638665926718012,
		0.34109589041095895, 0.3437458460720457, 0.34470072166407245, 0.34705396662109667,
		0.18767123287671234, 0.13664761398378308, 0.15055893589925004, 0.18151301452374832,
		0, 0, 0, 0,
		0.273972602739726, 0.26864282865877975, 0.2796094523843215, 0.2704422095588733,
		0.2054794520547945, 0.2078957862554832, 0.2029149568416584, 0.18909297635322625,
		0.4616438356164384, 0.4486242190615446, 0.4703551719258525, 0.44762381732291995,
		0.4356164383561644, 0.43705968363684705, 0.45761992358850995, 0.41919896046237765,
		0.34246575342465757, 0.3337764189817892, 0.35531342861185794, 0.3425872034001543,
		0.6479452054794521, 0.6111923434799947, 0.6697325597849159, 0.6357828340935854,
	})
	X := mat.NewDense(rows, cols, getDefaultXsamplesNoBiasSlice())
	max := []float64{4.52, 4.725, 4.333, 4.5909}
	min := []float64{-2.78, -2.798, -2.734, -2.797}
	type args struct {
		X   *mat.Dense
		max []float64
		min []float64
	}
	tests := []struct {
		name string
		args args
		want *mat.Dense
	}{
		{
			"Feature scalling with rescaling",
			args{
				X,
				max,
				min,
			},
			Xnorm,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := featureNormalizationMeanWithMaxMin(tt.args.X, tt.args.max, tt.args.min); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("featureNormalizationMeanWithMaxMin() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_featureNormalizationMean(t *testing.T) {
	const rows = 16
	const cols = 4
	Xnorm := mat.NewDense(rows, cols, []float64{
		1.8771666023371554, 1.9460145694809001, 1.8352127761167125, 1.9194396789791248,
		0.9670252193858074, 0.9142349742878602, 0.8781290932940408, 0.9484419198513414,
		-1.3746927138327654, -1.4298755217574517, -1.384256897998002, -1.3171720945355072,
		1.668592535410805, 1.610280445022581, 1.6955979531697432, 1.643481878717119,
		0.5688383643445926, 0.584992946158845, 0.5671250394190679, 0.5954208053728446,
		0.48825292939577536, 0.485617500203848, 0.4878334485936685, 0.500099413634293,
		0.033182237920101214, 0.04707639315932739, 0.052475916211102154, 0.04103917879390501,
		-0.40292717474408646, -0.3433768289317018, -0.3942915172191993, -0.3682262991681351,
		-0.9338429814657062, -1.0658544061500195, -1.05481405888555, -0.9482166578559392,
		-1.583266780759116, -1.5425597651875231, -1.5670560299737404, -1.5841668385594108,
		-0.6352028401847951, -0.6053792879357772, -0.6157495122385297, -0.6366437505314199,
		-0.8722188253283754, -0.817299860970932, -0.8766848020221756, -0.9216594541874871,
		0.014220959108614775, 0.022499171341245964, 0.03321869925289949, -0.0158691147813497,
		-0.0758451152459457, -0.017844570133717846, -0.010110038903056453, -0.11545862853804545,
		-0.39818685504121487, -0.37815591641011886, -0.3581842354225693, -0.38387607990133016,
		0.658904438699153, 0.589630157822634, 0.7115541666055878, 0.6433660427099966,
	})
	X := mat.NewDense(rows, cols, getDefaultXsamplesNoBiasSlice())
	mu := []float64{0.56, 0.52848125, 0.5210000000000001, 0.5434625000000001}
	sigma := []float64{2.1095623558770034, 2.1564683100596835, 2.0771433425099324, 2.108655741738482}
	type args struct {
		X *mat.Dense
	}
	tests := []struct {
		name  string
		args  args
		want  *mat.Dense
		want1 []float64
		want2 []float64
	}{
		{
			"Feature scalling with mean normalization",
			args{X},
			Xnorm,
			mu,
			sigma,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, got1, got2 := featureNormalizationMean(tt.args.X)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("featureNormalizationMean() got = %v, want %v", got, tt.want)
			}
			if !reflect.DeepEqual(got1, tt.want1) {
				t.Errorf("featureNormalizationMean() got1 = %v, want %v", got1, tt.want1)
			}
			if !reflect.DeepEqual(got2, tt.want2) {
				t.Errorf("featureNormalizationMean() got2 = %v, want %v", got2, tt.want2)
			}
		})
	}
}

func Test_featureNormalizationMeanWithMuSig(t *testing.T) {
	const rows = 16
	const cols = 4
	Xnorm := mat.NewDense(rows, cols, []float64{
		1.8771666023371554, 1.9460145694809001, 1.8352127761167125, 1.9194396789791248,
		0.9670252193858074, 0.9142349742878602, 0.8781290932940408, 0.9484419198513414,
		-1.3746927138327654, -1.4298755217574517, -1.384256897998002, -1.3171720945355072,
		1.668592535410805, 1.610280445022581, 1.6955979531697432, 1.643481878717119,
		0.5688383643445926, 0.584992946158845, 0.5671250394190679, 0.5954208053728446,
		0.48825292939577536, 0.485617500203848, 0.4878334485936685, 0.500099413634293,
		0.033182237920101214, 0.04707639315932739, 0.052475916211102154, 0.04103917879390501,
		-0.40292717474408646, -0.3433768289317018, -0.3942915172191993, -0.3682262991681351,
		-0.9338429814657062, -1.0658544061500195, -1.05481405888555, -0.9482166578559392,
		-1.583266780759116, -1.5425597651875231, -1.5670560299737404, -1.5841668385594108,
		-0.6352028401847951, -0.6053792879357772, -0.6157495122385297, -0.6366437505314199,
		-0.8722188253283754, -0.817299860970932, -0.8766848020221756, -0.9216594541874871,
		0.014220959108614775, 0.022499171341245964, 0.03321869925289949, -0.0158691147813497,
		-0.0758451152459457, -0.017844570133717846, -0.010110038903056453, -0.11545862853804545,
		-0.39818685504121487, -0.37815591641011886, -0.3581842354225693, -0.38387607990133016,
		0.658904438699153, 0.589630157822634, 0.7115541666055878, 0.6433660427099966,
	})
	X := mat.NewDense(rows, cols, getDefaultXsamplesNoBiasSlice())
	mu := []float64{0.56, 0.52848125, 0.5210000000000001, 0.5434625000000001}
	sigma := []float64{2.1095623558770034, 2.1564683100596835, 2.0771433425099324, 2.108655741738482}
	type args struct {
		X     *mat.Dense
		mu    []float64
		sigma []float64
	}
	tests := []struct {
		name string
		args args
		want *mat.Dense
	}{
		{
			"Feature scalling with mean normalization using existing mu and sigma",
			args{
				X,
				mu,
				sigma,
			},
			Xnorm,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := featureNormalizationMeanWithMuSig(tt.args.X, tt.args.mu, tt.args.sigma); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("featureNormalizationMeanWithMuSig() = %v, want %v", got, tt.want)
			}
		})
	}
}
